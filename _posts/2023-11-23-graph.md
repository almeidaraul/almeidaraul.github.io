---
layout: distill
title: Duplicate graph trick (PT-BR)
date: 2023-11-23 15:25:00-0300
description: A simple graph trick to solve some SSSP problems
tags: competitive_programming
giscus_comments: false
related_posts: false

authors:
  - name: Raul Almeida
    url: "https://almeidaraul.github.io"
    affiliations:
      name: DInf, UFPR
---

üöß em constru√ß√£o

Estas s√£o notas que acompanham a oficina que ministrei recentemente no Clube de Programa√ß√£o da UTFPR. Nela, eu apresentei o algoritmo de Dijkstra e um truque simples mas √∫til para resolver problemas no contexto de programa√ß√£o competitiva.

Como o truque √© simples, n√£o faz mal adicionar a explica√ß√£o do algoritmo de Dijkstra, mas voc√™ pode consult√°-la em outros lugares como o CP-Algorithms. Os problemas apresentados ser√£o tr√™s, sendo que os dois primeiros t√™m solu√ß√µes mais simples (mas servem para motivos did√°ticos).

# Nota√ß√£o
Os termos arco e aresta s√£o usados sem distin√ß√£o, bem como dist√¢ncia, peso e custo.
- $n$: n√∫mero de v√©rtices
- $m$: n√∫mero de arestas
- $E_{i,j}$: peso da aresta $(i, j)$


# Os problemas (enunciados resumidos)
- [Flight Discount (CSES)](https://cses.fi/problemset/task/1195): grafo direcionado, arcos com peso, $2 \leq n \leq 10^5$, $1 \leq m \leq 2\times10^5$. Encontre o menor caminho do v√©rtice $1$ ao $n$ sendo que voc√™ pode escolher uma aresta $e$ qualquer e mudar seu peso $E_e$ para $\lfloor\frac{E_e}{2}\rfloor$ (s√≥ pode fazer isso uma vez)
- [Our clients, please wait a moment (AtCoder)](https://atcoder.jp/contests/abc325/tasks/abc325_e): grafo direcionado, arcos com peso, $2 \leq n \leq 1000$, $m = \frac{n(n-1)}{2}$. Encontre o menor caminho do v√©rtice $1$ ao $n$ sendo que, para o caminho escolhido, todos os pesos $E_{i,j}$ valer√£o $E_{i,j}A$ at√© um ponto arbitr√°rio, e a partir da√≠ valer√£o $E_{i,j}B + C$. $1 \leq A, B, C \leq 10^6$
- [Moving Both Hands (Codeforces)](https://codeforces.com/contest/1725/problem/M): grafo direcionado, arcos com peso, $2 \leq n \leq 10^5$, $0 \leq m \leq 2\times10^5$. Para cada v√©rtice $u > 1$, encontre a menor dist√¢ncia para dois objetos se encontrarem seguindo os arcos, sendo que cada um se move de uma vez, um deles est√° no v√©rtice $1$, e o outro est√° no v√©rtice $u$.

# Dijkstra
Nos tr√™s problemas n√≥s usaremos o algoritmo de Dijkstra, ent√£o antes de irmos ao truque (e √†s solu√ß√µes) vamos ver este algoritmo em detalhe.

O algoritmo de Dijkstra resolve o problema de caminhos m√≠nimos com origem √∫nica (Single-Source Shortest Paths, SSSP) para grafos com arestas de peso n√£o-negativo. Neste problema, dado um v√©rtice de origem, o objetivo √© encontrar a menor dist√¢ncia para cada um dos outros v√©rtices num caminho que come√ßa na origem.

Para as explica√ß√µes a seguir, vamos fixar a origem no v√©rtice $1$.

## Intui√ß√£o
A ideia intuitiva do algoritmo √©: dado um v√©rtice $u$ que com
certeza tem caminho m√≠nimo $w$, para cada aresta $(u, v)$, √©
poss√≠vel que o menor caminho de $v$ tenha custo $w+E_{u,v}$. Isso
equivaleria a dizer que o caminho m√≠nimo de $v$ passa pela aresta
$(u, v)$. Posto de outra forma: para cada cara com caminho m√≠nimo
definido, vamos tentar descobrir um novo menor caminho para seus vizinhos.

## Algoritmo
Vamos guardar duas informa√ß√µes para cada v√©rtice $v$: se ele j√° foi processado e qual a menor dist√¢ncia conhecida de $1$ at√© ele ($d_v$). Inicialmente, $d_1 = 0$ e $d_v = \infty \forall v \neq 1$.

Para cada passo do algoritmo, vamos escolher o v√©rtice $v$ com o menor $d_v$ entre aqueles que n√£o foram processados ainda, e ent√£o process√°-lo. Processar um v√©rtice $v$ consiste em relaxar todas as arestas $(v, u)$ com a ideia apresentada na se√ß√£o anterior: $d_u = \min(d_u, d_v+E_{v,u})$.

√â f√°cil ver que cada v√©rtice s√≥ √© processado uma vez, porque s√≥ processaremos um v√©rtice que n√£o foi processado. Mas por que √© garantido que, ao processar um v√©rtice, j√° temos o menor valor poss√≠vel de $d_v$?

### Como funciona
Digamos que seja poss√≠vel que, ap√≥s processar o v√©rtice $v$, relaxemos alguma aresta que diminua o valor $d_v$.

Se houvesse arestas negativas, poderia acontecer de inserirmos $v$ num ciclo com soma negativa, e a√≠ seria poss√≠vel tornar $d_v = -\infty$ (veja o grafo abaixo). No nosso problema, n√£o h√° arestas negativas.

{% mermaid %}
graph LR
    1-->|2|b
    b-->|2|v
    v-->|1|x
    x-->|-10|1
{% endmermaid %}

Como n√£o h√° arestas negativas, o √∫nico jeito √© se encontrarmos algum v√©rtice $u$ com $d_u < d_v$, onde h√° um caminho de $u$ at√© $v$ com peso $x$ tal que $d_u + x < d_v$. No entanto, como processamos sempre o v√©rtice com menor dist√¢ncia primeiro, e como $d_u < d_v$, n√≥s ter√≠amos processado $u$ antes de $v$.

Portanto, ao processar o v√©rtice $v$, **j√° conhecemos o menor valor poss√≠vel para $d_v$.**

### Complexidade - observa√ß√µes
Agora, qual ser√° a complexidade desse algoritmo? Come√ßaremos por algumas observa√ß√µes.

#### Observa√ß√£o 1: cada v√©rtice √© processado uma vez
Cada v√©rtice √© processado apenas uma vez, porque n√£o processamos v√©rtices que j√° foram processados. Isso implica em um termo $\mathcal{O}(n)$ em algum lugar na complexidade final.

#### Observa√ß√£o 2: cada aresta √© relaxada uma vez
N√≥s relaxaremos uma aresta $(u, v)$ sempre que processarmos o v√©rtice de origem $u$, ou seja, uma vez. Isso implica em um termo $+\mathcal{O}(m)$ em algum lugar na complexidade final (separado do termo anterior).

Ignorando as complexidades de escolher o pr√≥ximo v√©rtice a processar e de relaxar uma aresta, temos uma complexidade de $\mathcal{O}(n+m)$.

#### Complexidade e c√≥digo para grafos densos
Em grafos densos, o n√∫mero de arestas √© pr√≥ximo do m√°ximo ($\frac{n(n-1)}{2}$). Se guardamos em um vetor booleano $m$ quais v√©rtices j√° foram processados, podemos a cada itera√ß√£o do algoritmo buscar o pr√≥ximo v√©rtice a ser processado em $\mathcal{O}(n)$, relaxando cada aresta em $\mathcal{O}(1)$. Isso significa uma complexidade $\mathcal{O}(n^2 + m) = \mathcal{O}(n^2)$. Para grafos densos, essa complexidade √© √≥tima. Abaixo deixo uma implementa√ß√£o do algoritmo nesse caso:

```cpp
using ii = pair<int, int>;
void dijkstra(int s, vector<vector<ii>> &g) {
	const int n = g.size();
	vector<int> d(n+1, 0x3f3f3f3f), m(n+1);
	d[s] = 0;
	for (int i = 0; i < n; ++i) {
		// escolhe o pr√≥ximo
		int v = 0;
		for (int j = 1; j < n; ++j)
			if (!m[j] && (m[v] || d[v] > d[j])
				v = j;
		// processa
		for (auto [x, u]: g[v])
			// relaxa aresta (v, u)
			d[u] = min(d[u], d[v]+x);
	}
}
```

#### Complexidade e c√≥digo para grafos esparsos
Quando o n√∫mero de arestas √© muito menor que o m√°ximo poss√≠vel, existe uma varia√ß√£o com desempenho melhor. O que vamos fazer √© guardar em uma estrutura que permita inser√ß√£o de valores e remo√ß√£o de m√≠nimo em tempo logar√≠tmico, e guardar nela pares $(d_v, v)$.

A melhoria dessa varia√ß√£o √© que a sele√ß√£o do pr√≥ximo v√©rtice a processar ter√° custo logar√≠tmico, j√° que basta selecionar o menor par na estrutura.

Ao mesmo tempo, relaxar uma aresta deixar√° de ser constante, porque ao encontrar um peso menor para o v√©rtice $u$ n√≥s teremos de adicion√°-lo √† estrutura em tempo logar√≠tmico.

Com essa altera√ß√£o, a complexidade do algoritmo passa a ser $\mathcal{O}(n\log n + m\log n)$, que √© muito melhor que a anterior no caso de grafos esparsos.

A implementa√ß√£o abaixo usa uma fila de prioridade, mas outras estruturas apresentam a mesma complexidade. Com uma _fibonacci heap_ √© poss√≠vel atingir tempo constante na inser√ß√£o e logar√≠tmico na remo√ß√£o, mas como ela √© muito mais dif√≠cil de implementar, n√£o √© t√£o adequada para programa√ß√£o competitiva.

```cpp
using ii = pair<int, int>;
void dijkstra(int s, vector<vector<ii>> &g) {
	const int n = g.size();
	vector<int> d(n+1, 0x3f3f3f3f);
	priority_queue<ii, vector<ii>, greater<ii>> pq;
	pq.emplace(d[s]=0, s);
	while (pq.size()) {
		// escolhe o pr√≥ximo
		auto [w, v] = pq.top(); pq.pop();
		if (w != d[v]) // descarta pares desatualizados
			continue;
		// processa
		for (auto [x, u]: g[v])
			// relaxa aresta (v, u)
			if (d[u] > w+x)
				pq.emplace(d[u]=(w+x), u);
	}
}
```

# Truque do grafo duplicado
Agora vamos ao truque que √© o ponto central disso tudo. √â uma t√©cnica de modelagem
bem simples, que s√≥ merece um nome porque essa p√°gina precisava de um t√≠tulo.

A t√©cnica consiste em duplicar o grafo, fazendo com que cada v√©rtice e aresta
tenha uma vers√£o "original" e uma "modificada". A modifica√ß√£o depende do problema.

Al√©m dos v√©rtices e arestas duplicadas, existir√£o arcos de transi√ß√£o entre o "grafo
original" e o "grafo duplicado". Isso vai fazer mais sentido quando olharmos para
os problemas, mas essencialmente esses arcos de transi√ß√£o representam decis√µes
irrevers√≠veis sobre a maneira como se caminha no grafo: a vers√£o duplicada do grafo
√© onde voc√™ caminha depois de tomar essas decis√µes.

# Solu√ß√µes com o truque
## Flight Discount
Esse √© o problema mais simples, com uma solu√ß√£o muito mais simples que essa, mas
√© bem f√°cil de pensar com esse truque. Aqui, a vers√£o duplicada do grafo vai ser
igual ao grafo original, e os arcos de transi√ß√£o ser√£o os arcos com o desconto
aplicado. Dessa maneira, o desconto s√≥ poder√° ser aplicado uma vez em um caminho
pelo grafo, porque n√£o existem arcos de retorno para a parte original.

Considere este grafo de exemplo:

{% mermaid %}
graph LR
    id1((1))  -->|7| id2((2))
    id2((2))  -->|4| id3((3))
{% endmermaid %}

Com o truque aplicado, ter√≠amos o grafo abaixo. A parte de cima √© id√™ntica ao
grafo original, bem como a parte de baixo. Os arcos que levam de cima para baixo
correspondem ao desconto aplicado. Note que n√£o h√° arcos de baixo para cima.

{% mermaid %}
graph LR
    id1((1))  -->|7| id2((2))
    id2((2))  -->|4| id3((3))
    id11((1')) -->|7| id21((2'))
    id21((2')) -->|4| id31((3'))
    id1((1))  -->|7/2 = 3| id21((2'))
    id2((2))  -->|4/2 = 2| id31((3'))
{% endmermaid %}

A implementa√ß√£o dessa solu√ß√£o √© muito simples. O c√≥digo do Dijkstra √© o mesmo,
e a constru√ß√£o do grafo √© levemente diferente:

```cpp
for (int i = 0; i < m; ++i) {
  int a, b, c;
  cin >> a >> b >> c;
  g[a].emplace_back(c, b);  // arco conforme na entrada
  g[a+n].emplace_back(c, b+n);  // arco duplicado (parte de "baixo" do grafo)
  g[a].emplace_back(c/2, b+n);  // arco de transi√ß√£o (desconto)
}
```

Neste c√≥digo, n√≥s reservamos os v√©rtices $1 \leq v \leq n$ para o grafo "original",
e os v√©rtices $n+1 \leq v' \leq 2n$ para o grafo duplicado.

## Our clients, please wait a moment
A ideia aqui √© muito parecida com a do problema anterior. Dessa vez os arcos de
transi√ß√£o ter√£o custo $0$, mas os pesos dos arcos ser√£o diferentes dependendo
de em qual parte do grafo voc√™ est√°. O grafo original corresponde ao prefixo
do caminho, que √© de carro, e o grafo duplicado corresponde ao sufixo, que √© de
trem.

```cpp
for (int i = 0; i < n; ++i)
  for (int j = 0; j < n; ++j) {
    int d;
    cin >> d;
    g[i].emplace_back(d*a, j);  // custo de carro: A*D(i,j)
    g[i].emplace_back(0, i+n);  // transi√ß√£o: custo 0
    g[i+n].emplace_back(d*b+c, j+n);  // custo de trem: B*D(i,j) + C
  }
```
